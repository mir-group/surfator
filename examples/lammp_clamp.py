import numpy as np

import os
import sys
from pathlib import Path

import ase
from ase.visualize import view

from surfator import StructureGroupAnalysis, STRUCTURE_GROUP_ATTRIBUTE
import surfator.agreement_groups
from surfator.analysis import calculate_coord_numbers
from surfator.util.layers import get_layer_heights_kmeans
from surfator.structure_groups import ClosePackedReferenceSites

from sitator import SiteNetwork
from sitator.misc import GenerateClampedTrajectory
from sitator.dynamics import SmoothSiteTrajectory

from tqdm.autonotebook import tqdm

import logging


def read_refstruct(fpath):
    """Read a reference structure generated by David's code

    Returns:
        surface_normal
        positions (n x 3 ndarray float),
        layers (n ndarray int),
        site_type (n ndarray object)
    """
    skiprows = 2
    with open(fpath) as f:
        normarr = f.readline().strip().split()
        assert normarr[:2] == ["Normal",  "vector"]
        normal = np.array(normarr[-3:], dtype = np.float)
        header = f.readline()
        assert header.strip().split("\t") == ['x', 'y', 'z', 'Layer #', 'Site type']
    positions = np.loadtxt(fpath, skiprows = skiprows, usecols = (0, 1, 2))
    layers = np.loadtxt(fpath, skiprows = skiprows, usecols = (3), dtype = np.int)
    layer_types =  np.loadtxt(fpath, skiprows = skiprows, usecols = (4), dtype = np.object)
    return normal, positions, layers, layer_types


# ---- FROM ASE https://gitlab.com/ase/ase/blob/master/ase/io/lammpsrun.py ----
# Based on ASE's code for loading lammpstrj (which we don't use because its
# performance is very bad)
def construct_cell(celldata):
    """
    ASE's original docs:

    Help function to create an ASE-cell with displacement vector from
    the lammps coordination system parameters.

    :param diagdisp: cell dimension convoluted with the displacement vector
    :param offdiag: off-diagonal cell elements
    :returns: cell and cell displacement vector
    :rtype: tuple
    """
    diagdisp = celldata[:, :2].reshape(6, 1).flatten()
    offdiag = celldata[:, 2]

    xlo, xhi, ylo, yhi, zlo, zhi = diagdisp
    xy, xz, yz = offdiag

    # create ase-cell from lammps-box
    xhilo = (xhi - xlo) - abs(xy) - abs(xz)
    yhilo = (yhi - ylo) - abs(yz)
    zhilo = zhi - zlo
    celldispx = xlo - min(0, xy) - min(0, xz)
    celldispy = ylo - min(0, yz)
    celldispz = zlo
    cell = np.array([[xhilo, 0, 0], [xy, yhilo, 0], [xz, yz, zhilo]])
    celldisp = np.array([celldispx, celldispy, celldispz])

    return cell, celldisp


def read_lammpstraj(path):
    """
    Assumes unchancing cell/box bounds and unchanging number of atoms.

    !!! ASSUMES SORTED OUTPUT !!!

    Returns:
        - traj
        - frame_times
        - atoms
        - cellstr
    """

    frames = []
    frame_times = []
    n_atoms = None
    cell = None

    with open(path) as f:
        # f will raise StopIteration
        try:
            first_frame = True
            while(True):
                assert next(f).startswith("ITEM: TIMESTEP")
                processed_full_frame = False
                frame_times.append(int(next(f)))
                assert next(f).startswith("ITEM: NUMBER OF ATOMS")
                n_atoms = int(next(f))
                assert next(f).startswith("ITEM: BOX BOUNDS xy xz yz pp pp ff")
                cellstr = [next(f) for _ in range(3)]
                celldata = np.loadtxt(cellstr)
                cellstr = "ITEM: BOX BOUNDS xy xz yz pp pp ff\n" + "".join(cellstr).strip()
                cell, _ = construct_cell(celldata)
                assert next(f).startswith("ITEM: ATOMS id type xu yu z")
                frame = np.empty(shape = (n_atoms, 3))
                if first_frame:
                    types = np.empty(shape = n_atoms, dtype = np.int)
                    ids = np.empty(shape = n_atoms, dtype = np.int)
                for atom_i in range(n_atoms):
                    lsplit = next(f).split()
                    frame[atom_i] = lsplit[2:5]
                    types[atom_i] = lsplit[1]
                    ids[atom_i] = lsplit[0]
                frames.append(frame)
                processed_full_frame = True
                first_frame = False
        except StopIteration:
            pass

    assert processed_full_frame

    frames = np.asarray(frames)
    frame_times = np.asarray(frame_times)

    # Make atoms
    atoms = ase.Atoms(positions = frames[0], cell = cell, pbc = True)
    atoms.set_atomic_numbers(types)
    atoms.set_tags(ids)

    return frames, frame_times, atoms, cellstr


def write_lammpstraj(path, cellstr, traj, atoms, coords = None, timesteps = None):
    """WARNING: this function is NOT generic AT ALL

    JUST FOR SOME REALLY SPECIFIC TRAJECTORY FILES
    """
    if timesteps is None:
        timesteps = np.arange(len(traj))

    n_atoms = traj.shape[1]
    assert traj.shape[2] == 3

    if coords is None:
        atoms_header = "ITEM: ATOMS id type x y z"
        atom_format = "{} {} {:05f} {:05f} {:05f}"
    else:
        atoms_header = "ITEM: ATOMS id type xu yu z c_cn "
        atom_format = "{} {} {:05f} {:05f} {:05f} {:d}"

    ids = atoms.get_tags()
    types = atoms.get_atomic_numbers()

    with open(path, 'w') as f:
        for f_idex, frame in enumerate(traj):
            print("ITEM: TIMESTEP", file = f)
            print(timesteps[f_idex], file = f)
            print("ITEM: NUMBER OF ATOMS", file = f)
            print(n_atoms, file = f)
            print(cellstr, file = f)
            print(atoms_header, file = f)
            for atom_i in range(n_atoms):
                print(atom_format.format(ids[atom_i], types[atom_i], frame[atom_i, 0], frame[atom_i, 1], frame[atom_i, 2], (None if coords is None else coords[f_idex, atom_i])), file = f)

    return


def main(traj_path,
         ref_path,
         out_path,
         n = None,
         trajslice = None,
         cutoff = 3,
         min_layer_dist = 1.0,
         runoff_votes_weight = 0.6,
         winner_bias = 0.5,
         assign_cutoff = None,
         agreegrp_cutoff = None,
         skin = 0,
         min_winner_percentage = 0.50001):
    """
    Args:
        - traj (ndarray n_frames x n_atoms x 3)
        - ref_structure (ASE atoms len(.) = n_atoms)
        - cutoff (float, Angstrom): For computing coordination number
    """
    fh = logging.FileHandler(os.path.join(out_path, 'surfator.log'), mode = 'w')
    surfator_log = logging.getLogger("surfator")
    surfator_log.setLevel(logging.INFO)
    surfator_log.addHandler(fh)
    sitator_log = logging.getLogger("sitator")
    sitator_log.setLevel(logging.INFO)
    sitator_log.addHandler(fh)

    print("Loading trajectory and reference structure...")
    traj, timesteps, atoms, cellstr = read_lammpstraj(traj_path)

    surface_normal, ref_positions, layers, ref_site_types = read_refstruct(ref_path)
    ref_sn = ClosePackedReferenceSites(
        reference_positions = ref_positions,
        layer_labels = layers,
        layer_type_labels = ref_site_types,
        structure = atoms,
        static_mask = np.zeros(len(atoms), dtype = np.bool),
        mobile_mask = np.ones(len(atoms), dtype = np.bool),
    )

    if trajslice is not None:
        trajslice = slice(*(None if e == '' else int(e) for e in trajslice.split(":")))
        traj = traj[trajslice]
        timesteps = timesteps[trajslice]

    print("Cell:")
    print(atoms.cell)

    print("Determining layers...")
    assert n is not None
    heights_kmeans_stride = max(len(traj) // 300, 1)  # Why not? 300 frames of heights sounds reasonable
    layers = get_layer_heights_kmeans(traj[::heights_kmeans_stride], atoms.cell, n, surface_normal = surface_normal)
    print("Layer heights: %s" % layers)

    print("Assigning to reference sites...")
    if assign_cutoff is None:
        assign_cutoff = cutoff

    # layerfunc = surfator.agreement_groups.layers.agree_within_layers_kmeans(
    #     initial_layer_heights = layers,
    #     surface_normal = surface_normal,
    #     min_layer_dist = min_layer_dist
    # )
    layerfunc = surfator.agreement_groups.layers.agree_within_layers(
        layer_heights = layers,
        surface_normal = surface_normal,
        #cutoff_above_top = assign_cutoff # Be a little more generous on top.
    )
    if agreegrp_cutoff is None:
        agreegrp_cutoff = 1.5 * cutoff
    agreefunc = surfator.agreement_groups.layers.agree_within_components_of_groups(
        layerfunc,
        cutoff = agreegrp_cutoff
    )

    sga = StructureGroupAnalysis(
        min_winner_percentage = min_winner_percentage,
        runoff_votes_weight = runoff_votes_weight,
        winner_bias = winner_bias,
        error_on_no_majority = False
    )
    st, agreegrp_assign, structgrp_assign = sga.run(
        ref_sn = ref_sn,
        traj = traj,
        cutoff = assign_cutoff,
        agreement_group_function = agreefunc,
        return_assignments = True,
    )
    np.save(os.path.join(out_path, "agreegrp-assignments.npy"), agreegrp_assign)
    np.save(os.path.join(out_path, "structgrp-assignments.npy"), structgrp_assign)
    print("    Percent unassigned: %.2f%%" % (100 * st.percent_unassigned))
    print("    Average majority: %i%%; minimum majority %i%%" % (100 * sga.average_majority, 100 * sga.minimum_majority))
    st.compute_site_occupancies()
    occs = st.site_network.occupancies
    print("    Min occupancy: %.2f; avg. occupancy: %.2f; max occupancy: %.2f" % (np.min(occs), np.mean(occs), np.max(occs)))
    n_multiple_assign, _ = st.check_multiple_occupancy(max_mobile_per_site = 2)
    print("    n multiple assignment: %i" % n_multiple_assign)

    print("Removing short jumps...")
    sst = SmoothSiteTrajectory(
        window_threshold_factor = 3/2,
        set_unassigned_under_threshold = False # Maintain short transitions, only eliminate failed attempts
    )
    st = sst.run(st, threshold = 2)
    print("    Percent unassigned: %.2f%%" % (100 * st.percent_unassigned))
    n_multiple_assign, _ = st.check_multiple_occupancy(max_mobile_per_site = 2)
    print("    n multiple assignment: %i" % n_multiple_assign)

    print("Clamping trajectory...")
    gct = GenerateClampedTrajectory(wrap = False, pass_through_unassigned = True)
    clamped_traj = gct.run(st)

    print("Computing new coordination numbers...")
    # Now get coordination numbers
    coords = calculate_coord_numbers(traj = clamped_traj,
                                     atoms = atoms,
                                     cutoff = cutoff,
                                     skin = skin)
    nums, counts = np.unique(coords, return_counts = True)
    maxcount = np.max(counts)
    width = 50
    print("Coordination histogram:")
    for n, c in zip(nums, counts):
        print(("  {:3d}: {:%is}    (x{:8d})" % width).format(n, "#" * int(width * c / maxcount), c))

    print("Writing trajectory out...")
    write_lammpstraj(os.path.join(out_path, "clamped-vmd.out"), traj = clamped_traj, atoms = atoms, timesteps = timesteps, cellstr = cellstr)
    write_lammpstraj(os.path.join(out_path, "clamped.out"), traj = clamped_traj, atoms = atoms, coords = coords, timesteps = timesteps, cellstr = cellstr)
    print("Done.")


if __name__ == "__main__":
    argv = sys.argv

    if len(argv) == 5:
        import json
        kwargs = argv[3]
        if kwargs[0] == '{':
            kwargs = json.loads(kwargs)
        else: # It's a path
            with open(kwargs) as f:
                kwargs = json.load(f)
    elif len(argv) == 4:
        kwargs = {}
    else:
        print("lammp-clamp.py traj_path ref_path [\"json-kwargs-str\"|/path/to/kwargs.json] out_path")
        sys.exit(-1)

    main(*argv[1:3],
         out_path = argv[-1],
         **kwargs)
